# 06 轻量编辑器与数据导出

## 设计原则
编辑器必须足够轻量，满足“玩家可用”而不是“策划专业工具”：
- **只做顺序重排**：槽位卡片上下移动
- **只做档位切换**：每槽位下拉选择预置 option
- **实时反馈**：展示导出的 Assembly（以及预算）
- **一键应用**：将当前 Assembly 应用到战斗（PVE 验证）
- **指示器可预览（建议）**：编辑器可显示当前模板的指示器预览（线/扇/圆/突进路径），但不提供自由绘制

## UI 结构
左侧配置，右侧战斗：
- 模板选择（Template 下拉）
- 槽位链（Slot 卡片列表）
  - 上移/下移按钮
  - 档位下拉（Option）
- 操作按钮
  - 应用到战斗
  - 重置默认
  - 刷新怪物 / 暂停
- 导出区（Assembly JSON）

当前实现文件：
- 页面：`editor/index.html`
- 逻辑：`editor/play.js`

## 数据导出格式（建议）
建议导出两层：
1) **PlayerAssembly（玩家存档层）**：最小可持久化
```json
{
  "templateId": "tpl_ranged_proj_v1",
  "order": ["c1","t1","c2","a2","a3","a1","tl1"],
  "slotOptions": { "c1":"mana30", "t1":"coneW", "c2":"range18", "...":"..." },
  "version": 1,
  "signature": "..."
}
```

2) **RuntimeIR（运行时层）**：服务端/战斗端执行用
- `ops[]`（每个 op 带 eval/exec/select 的映射在运行时生成）
- `guards`
- `budgets`

本项目当前 demo 为便捷，导出里直接展示了编译后的结构摘要（便于调试）。

## Signature（签名）与版本冻结（后续对接）
本阶段 demo 的 signature 是“弱签名”（仅用于示意）。上线形态建议：
- 保存时服务端将 `normalized(PlayerAssembly)` 做 hash，并用 server secret 签名
- 战斗端只接受签过的 assembly，避免客户端篡改

版本冻结建议：
- `templateId + templateVersion` 固定
- 若模板/档位/预算发生改动，生成新版本；旧版本只允许继续使用或做迁移

## 与 PVE 验证的衔接
编辑器“应用到战斗”的真实动作是：
- 重新 `compileAssembly(template, order, slotOptions)` 得到 `RuntimeIR`
- `EventBus` 替换当前 IR 订阅（下一次 CastConfirm/OnDamaged 即按新顺序生效）

## 与表现层的衔接（新增）
为保证“手感不漂”，推荐在 Template/Option 中同时携带最小表现参数（但仍由档位固定）：
- `windupMs` / `recoveryMs`
- `indicatorShape`（line/cone/circle/dash）
- `projectileSpeed`
- `sfxId` / `vfxId`

编辑器在展示 Assembly 时可同时显示“本次施法体验摘要”：\n+前摇时长、指示器形状、弹速档位，帮助玩家理解顺序调整带来的变化（见 `07_表现层与手感设计.md`）。

## 启动方式（本地试玩）
通过本地静态服务器启动（见 `server.js` 与 `package.json` 的 `dev` 脚本），浏览器打开：
- `http://127.0.0.1:5173/`

若端口占用，可设置环境变量换端口：
```powershell
$env:PORT=5174
npm run dev
```

